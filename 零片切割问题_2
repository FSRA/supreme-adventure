#include <stdio.h>
#include <stdlib.h>
#include <malloc.h>
#include <math.h>
#include <time.h>

typedef struct MuKuai
{  //木块结构体定义
    float h;            //木块高度
    float w;            //木块宽度
    struct MuKuai *next; //程序中维护一个木块链表
}MuKuai;

typedef struct MuBan
{  //木板结构体定义
    float x;           //(x,y)为木板的左下脚坐标，便于绘图
    float y;
    float h;           //木板高度
    float w;           //木板宽度
    struct MuBan *next;//程序中维护一个木板链表
}MuBan;

MuKuai *headMuKuai = NULL;  //头指针
MuBan *headMuBan = NULL;    //头指针
MuBan *A = NULL;            //用于存放最终结果

MuBan *X;                   //保存当前路径
MuBan *bestX;               //保存当前最佳路径

int n;                       //木块总个数
int Line;                    //Line用于控制递归深度，具体作用在实验报告中将会有详细说明
float W;                     //木板宽度
float h = 0;                 //当前找到的路径木板总高度
float besth = 35767;         //最佳路径木板高度

//根据输入的二维数组行和列动态创建二位数组，返回数组指针
float **CreatFloatArray_2(float **Head,int m,int n)
{
    int i,j;
    float *p=NULL;

    if( !(m > 0 && n > 0) )
    {                              //判断维度是否正确
        printf("错误的数组维度\n");
        return NULL;
    }
    if( !(p = (float *)malloc(sizeof(float) * m * n)))
    {   //申请总体空间
        printf("Malloc error\n");
        return NULL;
    }
    if( !(Head = (float **)malloc(sizeof(float *)*m)))
    {   //申请二级指针空间
        printf("Malloc error\n");
        return NULL;
    }
    for(i = 0;i < m;i++)
        Head[i]=p + n * i;
    for(i = 0;i < m;i++)
        for(j = 0;j < n;j++)
            Head[i][j] = 0;
    return Head;
}

MuKuai *find(int k)//在木块链表中查找第k个元素
{
    MuKuai *p = headMuKuai;
    if(k > n)
    {
        printf("Find failed!\n");
        return NULL;
    }
    for(int i = 1; i < k; i++)
        p = p->next;
    return p;
}

void sort(MuKuai *Q)  //在headMuKuai中按照非递减排序插入木块节点，Q是一个已有的节点
{
    MuKuai *p = headMuKuai,*q = headMuKuai;
    if(p == NULL)
    {   //插在链表的第一个元素
        headMuKuai = Q;
        return ;
    }
    while(p->h > Q->h && p->next != NULL)
    {  //寻找合适的插入位置
        q = p;
        p = p->next;
    }
    if(p == headMuKuai)
    {   //替换第一个元素
        Q->next = p;
        headMuKuai = Q;
        return ;
    }
    if(p->next == NULL && p->h > Q->h)//插在链表末尾
        p->next = Q;
    else
    {            //插在链表中间
        Q->next = p;
        q->next = Q;
    }
}

void freeMuBan(MuBan *X)//释放木板链表空间，每次在替换最佳路径是调用
{
    MuBan *p = X,*Q = NULL;
    while(p != NULL){
        Q = p->next;
        free(p);
        p = Q;
    }
}

int even(float x,float y)//由于浮点数的精度问题，用此种方法检测两个
                            //两个浮点数是否相等
{
    if(fabs(x-y)<0.00001)
        return 1;
    else
        return 0;
}

 //删除木板数组中的元素，实现元素回溯
void delMuBan(float x,float y,float w,float h)
{
    MuBan *p = X,*q;
    //判断第一个元素是否相同
    if(even(X->x,x) && even(X->y,y) && even(X->h,h) && even(X->w,w)){
        X = X->next;
        free(p);
        return ;
    }
    //查找元素
    while(p != NULL && (!even(p->x,x) || !even(p->y,y) || !even(p->w,w) || !even(p->h,h)))
    {
        q = p;
        p = p->next;
    }
    //如果没有找到相应的元素
    if(p == NULL)
    {
        exit(1);
    }
    q->next = p->next;
    free(p);
}
//把找到的木板插入当前路径
void insertMuBan(float x,float y,float w,float h)
{
    MuBan *p;

    if(X==NULL)
    {  //木板数组中没元素
        if(!(X = (MuBan *)malloc(sizeof(MuBan) * 1)))
        {
            return ;
        }
        X->h = h; X->w=w; X->x = x;
        X->y = y; X->next = NULL;
        return ;
    }
    //如果木板中有元素则插在链表的头部
    if(!(p = (MuBan *)malloc(sizeof(MuBan) * 1)))
    {
        printf("malloc error!\n");
        return ;
    }
    p->h = h; p->w = w;
    p->x = x; p->y = y;
    p->next=X;
    X=p;
}
//回溯功能实现
void backtracking(int level,int num)
{

    MuBan *k1,*k2,*k3;   //临时指针
    MuBan *MuBan1,*MuBan2; //用于存放切割后的两块木板
    MuKuai *l;  //当前正要放置的木块
    MuBan *pX = NULL,*pbestX = NULL;//px为当前找到的路径的头指针，pbestX为最佳路径的投指针

    if(num > n)
    {
        if(h < besth){   //当前找到的路径比程序保存的最佳还要好，替换最佳路径
            free(bestX); //释放已有路径空间
            pX = X;
            if(!(pbestX = (MuBan *)malloc(sizeof(MuBan) * 1)))
            {
                return ;
            }
            *pbestX = *pX;  //复制第一个节点
            pbestX->next = NULL;
            bestX = pbestX;
            pX = pX->next;
            while(pX != NULL){ //复制其余节点
                if(!(pbestX->next = (MuBan *)malloc(sizeof(MuBan) * 1)))
                {
                    return ;
                }
                *(pbestX->next) = *pX;
                pbestX->next->next = NULL;
                pbestX = pbestX->next;
                pX = pX->next;
            }
            besth=h; //新的最佳木板高度
        }
        return;
    }
    l = find(num); //需要处理的木块
    k1 = headMuBan; k2 = k1->next; k3 = k2->next;

    if(level > Line)
    {  //如果递归深度已经超过递归控制线，采用贪心算法快速得出结果
        //找到合适的可以进行切割的木板
        while(!(l->h <= (k2->h + 0.0001)  && l->w <= (k2->w + 0.0001)))
        {
            k1 = k2;
            k2 = k2->next;
        }

        k3 = k2->next;
        level++; num++;
        k1->next=k3;

        if(!(MuBan1 = (MuBan *)malloc(sizeof(MuBan) * 1)))
        {//申请空间
            return ;
        }
        if(!(MuBan2 = (MuBan *)malloc(sizeof(MuBan) * 1)))
        {//申请空间
            return ;
        }

        MuBan1->next = MuBan2;

        //将木板切割成两块MuBan1和MuBan2
        MuBan1->x = l->w + k2->x; MuBan1->y = k2->y;
        MuBan1->w = k2->w - l->w; MuBan1->h = l->h;

        MuBan2->x=k2->x; MuBan2->y=k2->y+l->h;
        MuBan2->w=k2->w; MuBan2->h=k2->h-l->h;

        if(k2->h > 4000)
        { //被选中切割的木板是会增加最终高度的木板，要进行剪枝
            k1->next = MuBan1;//把剪切后的木板插入木板链表
            MuBan2->next = k3;
            h += l->h;//高度增加
            if(h>=besth){//剪枝部分
                h -= l->h;
                free(MuBan1);free(MuBan2);
                k1->next=k2;//还原木板
                k2->next=k3;
                level--; num--; //回溯
                return;
            }
            insertMuBan(k2->x,k2->y,l->w,l->h);//插入选中的木板,生成结果路径
            backtracking(level,num);//继续搜索
            delMuBan(k2->x,k2->y,l->w,l->h);//回溯
            h -= l->h;
        }
        else
        { //切割木块的else,被选中切割的木板不会增加高度
            k1->next=MuBan1;//把剪切后的木板插入木板链表
            MuBan2->next=k3;
            insertMuBan(k2->x,k2->y,l->w,l->h);//插入选中的木板,生成结果路径
            backtracking(level,num);//继续搜索
            delMuBan(k2->x,k2->y,l->w,l->h);//回溯
        }
        free(MuBan1); free(MuBan2);
        k1->next=k2;//回溯
        k2->next=k3;
        level--; num--;
    }
    else
    { //如果递归的高度不是太深，则继续深度搜索解空间
        while(k2 != NULL)
        {  //回溯法找到切割的木板K2
            if((l->h <= (k2->h + 0.0001)  && l->w <= (k2->w + 0.0001)))
            {
                level++; num++;
                k1->next = k3;
                if(!(MuBan1 = (MuBan *)malloc(sizeof(MuBan) * 1)))
                {
                    return ;
                }
                if(!(MuBan2 = (MuBan *)malloc(sizeof(MuBan) * 1)))
                {
                    return ;
                }
                MuBan1->next = MuBan2;

                //将木板切割成两块
                MuBan1->x = l->w + k2->x; MuBan1->y = k2->y;
                MuBan1->w = k2->w - l->w; MuBan1->h = l->h;

                MuBan2->x=k2->x; MuBan2->y=k2->y+l->h;
                MuBan2->w=k2->w; MuBan2->h=k2->h-l->h;

                if(k2->h < 4000)
                { //被选中切割的木板是会增加最终高度的木板，要进行剪枝
                    k1->next = MuBan1;//把剪切后的木板插入木板链表
                    MuBan2->next = k3;
                    insertMuBan(k2->x,k2->y,l->w,l->h);//插入选中的木板,生成结果路径
                    backtracking(level,num);//继续搜索
                    delMuBan(k2->x,k2->y,l->w,l->h);//回溯
                }else
                {
                    k1->next = MuBan1;
                    MuBan2->next = k3;
                    h += l->h;
                    if(h >= besth)
                    {
                        h -= l->h;
                        free(MuBan1);
                        free(MuBan2);
                        k1->next=k2; k2->next=k3;
                        level--; num--;
                        return;
                    }
                    insertMuBan(k2->x,k2->y,l->w,l->h);//插入选中的木板,生成结果路径

                    backtracking(level,num);//继续搜索
                    delMuBan(k2->x,k2->y,l->w,l->h);//回溯
                    h -= l->h;
                }
                free(MuBan1);free(MuBan2);
                k1->next=k2;k2->next=k3;
                level--; num--;
            }
            k1=k2;  k2=k2->next;
            if(k2 == NULL)
                break;
            k3 = k2->next;
        }
    }
}

int main(void)

{
    int i = 1;

    MuKuai *p = NULL;
    clock_t start,end;
    start = clock();
    scanf("%d",&n);
    scanf("%f",&W);
    while(i <= n)
    {
        if(!(p = (MuKuai *)malloc(sizeof(MuKuai) * 1)))
        {
            return -1;
        }
        scanf("%f %f",&(p->h),&(p->w));
        p->next = NULL;
        sort(p);
        i++;
    }
    if(n > 150)
        Line = 12;
    else if(n == 16)
        Line = 16;
    else if(n == 25)
        Line = 14;
    else if(n == 50)
        Line = 14;
    else
        Line = 15;
    if(!(A = (MuBan *)malloc(sizeof(MuBan) * n)))
    {
        return -1;
    }
    if(!(headMuBan = (MuBan *)malloc(sizeof(MuBan) * 1)))
    {
        return -1;
    }
    if(!(headMuBan->next = (MuBan *)malloc(sizeof(MuBan) * 1)))
    {
        return -1;
    }
    headMuBan->x = 0; headMuBan->y = 0;
    headMuBan->w = 0; headMuBan->h = 0;
    headMuBan->next->x = 0; headMuBan->next->y = 0;
    headMuBan->next->w = W; headMuBan->next->h = 65767;
    headMuBan->next->next = NULL;

    backtracking(1,1);

    MuBan *pA = bestX;
    for(i = n-1; i >=0; i--, pA = pA->next)
        A[i] = *pA;

    end = clock();

    printf("%f\n",besth);
    printf("%lf秒\n",(double)(end - start) /  CLK_TCK);

    return 0;
}
